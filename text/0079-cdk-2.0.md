---
feature name: cdk-2.0
start date: 2020-3-29
rfc pr: https://github.com/aws/aws-cdk-rfcs/pull/156
related issue: https://github.com/aws/aws-cdk-rfcs/issues/6
---

<!-- replace the blockquoted sections with your content -->

# Summary

CDK v2.0!

This RFC details the strategy for building and releasing aws-cdk 2.0, in addition to changes to tooling required to
support this strategy. For details on the specific features themselves, see the corresponding RFCs.

# Motivation

Since the CDK was announcned as "generally available", the team has tried to limit breaking changes for users. However,
a handful of features have emerged that the core team believes will make the CDK significantly simpler to use. These
changes require a 2.0 release to signal to users that code changes may be required for adoption.

The main change of note is to consolidate all of the aws service construct libraries into a single package. The
motivation for this change is detailed in [the corresponding RFC](https://github.com/aws/aws-cdk-rfcs/issues/6).

The core motivation of this proposal is to detail the plan required to release this change while continuing to support
users referencing the v1 modules. In short, we want to make sure users have plenty of time to transition their code to
using the new module structure and make that transition as easy as possible.

# Basic Example

## New Module Structure

_Installing aws-cdk 2.0_

```bash
npm install aws-cdk @aws-cdk/stdlib
```

_Importing modules from aws-cdk 2.0_

```typescript
import { aws_ecs as ecs, aws_lambda as lambda, aws_s3 as s3 } from '@aws-cdk/stdlib';
```

# Scope

CDK 2.0 consists of the following notable changes:

- [Monolithic Packaging](https://github.com/aws/aws-cdk-rfcs/issues/6) - Combine all aws construct libraries into a
  single package.
- [Removal of All Union Types](https://github.com/aws/aws-cdk/issues/5067) - Replace those with a single type that
  translates gracefully in languages that do not support type unions (Java, C#, ...).
- [Reset all Feature Flags](https://github.com/aws/aws-cdk-rfcs/issues/55) - Delete all defined feature flags and
  extraneous logic for the "old" state.
- Remove Deprecated APIs - Delete all constructs/methods marked with `@deprecated` flag.

# Detailed Design

## Branching Model

### Goals

Since the new release includes breaking changes, it is necessary to fork the codebase. The release strategy should
reduce manual effort needed in order to forward-port new feature work merged into the v1 development branch. It also
tries to minimize the amount of "v2 awareness" that needs to be encoded into the v1 codebase during the transition
period.

### Process Flow

At the inception of this project, a new branch (which will be referred to as `next` in this document, regardless of the
actual name that will be used) will be created in the GitHub repository. This new branch will get a lightweight
continuous integration set-up to facilitate development iteration on this codebase. This will minimally consist of
validation builds, and could be implemented using GitHub actions. The `next` branch codebase will initially be generated
by a foward-porting tool that copies source from the v1 codebase while applying the following transformations:

- removal of all API elements annotated as `@deprecated`
- re-packaging of all AWS Construct Library modules (most modules namespaced within `@aws-cdk`) into a single package
  named `@aws-cdk/stdlib`, including any and all assoaciated tests
- re-writing of all `import` statements referring to AWS Construct Library modules so they refer to `@aws-cdk/stdlib`
  instead

Once the initial fork has been created, an exclusion list will be added to the forward-porting tool, so that it can be
automatically re-applied by a GitHub action triggered on each new commit pushed to the v1 branch, transparently adding
commits on the `next` branch reflecting new developments on the v1 branch. The exclusion list will contain the modules
that require forking in order to deliver the changes in-scope for the new major version.

### Removal of TypeScript type unions

#### Forking `cfn2ts`

The AWS CloudFormation Resources layer (aka: L1 constructs) is generated by the `cfn2ts` tool, and makes
quasi-systematic use of type unions with the following shape:

- the CloudFormation Resource Specification declared type of a property or attribute
  - if this type is a collection (list or map), the element type is a type union of similar shape
- the `IResolvable` interface that used the be the only way to represent tokens (deploy-time values)

The vast majority of those type unions could be replaced by only the CloudFormation Resource Specification declared
type, since there are better mechanisms for encoding tokens directly within the most common types (`string`, `number`,
and collections thereof). Complex property types (structs) are not a concern as CloudFormation only supports scalar
values for references (results of `Fn::GetAtt`, `Ref`, ...).

The `boolean` type is however problematic as there is no way to encode a token as a boolean. A solution is to introduce
a new `CfnBoolean` type to wrap a literal or token as appropriate. A similar strategy can be used for other types that
cannot natively encode a token.

#### Cleaning up the AWS Construct Library

The AWS Construct Library is a hand-crafted codebase, in which type unions are not widely used. The few APIs that make
use of type unions will need to be replaced by alternatives that do not use a type union. Since the forward-porting tool
removes any `@deprecated` element from the codebase, a simple way to prepare the `next` release is to proactively
deprecate those APIs while adding a better alternative.

In order to facilitate detection, the `jsii` compiler will be modifierd to support a new option that causes a
compilation failure to be thrown when a type union is detected. This will be globally turned on in the `next` branch. A
tool may be provided to inspect jsii assemblies created by the v1 codebase and report any type union present on
hand-written APIs (that is, not those generated by `cfn2ts`).

### Feature Flag Resetting

Feature flags introduced during the v1 cycle are not allowed to be toggled within v2. This will require users with apps
created before a certain feature flag was introduced, to change their code in order to handle the new behavior if they
haven't already.

The CDK should enforce this and ideally also be version aware. If a user has a feature flag configured in their
`cdk.context` file that is no longer configurable, due to its introduction being during the previous major version
cycle, aws-cdk command line interactions should emit an error instructing the user to remove the feature flag and make
any required code changes. Ideally with some information about the specific behavior changes introduced by the feature
flag and links to any documentation to help with migration.

### Namespace Aware Documentation

Currently, CDK doc generation makes some assumptions about the structure of modules. If we were to generate
documentation for the `@aws-cdk/stdlib` module with the current doc generation, the left panel of the main documentation
site would list only a single module, that being `@aws-cdk/stdlib`. Ideally the structure of the documentation will
remain similar to how it is today, with all of the immediate children of the top level export showing on the left panel.
An exception may have to be made for the contents of the current `@aws-cdk/core` module, since those will all be exposed
at the modules top level. Having all of those take up space on the left navigation panel may introduce unwanted noise.

### Migration Tooling

In addition to the above changes to build tools, an effort will be made to provide tooling to make migration for users
as easy as possible.

#### Import Rewriter

##### TypeScript

A command line tool to change the import statements in an existing cdk application written in TypeScript from the old
multi-module to the new single module structure:

```typescript
import { App, Stack } from '@aws-cdk/core';
import * as s3 from '@aws-cdk/aws-s3';
import { Cluster, Service } from '@aws-cdk/aws-ecs';
```

would automatically be changed to:

```typescript
import { App, Stack } from '@aws-cdk/stdlib';
import * as s3 from '@aws-cdk/stdlib/s3';
import { Cluster, Service } from '@aws-cdk/stdlib/ecs';
```

##### Other Languages

CDK applications written in Java and DotNet (C#, F#, ...) will not need to update `import`/`using` statements, as
`jsii-pacmak` will be configured to emit identical package/namespace names as v1.

The Python modules layout generated for `next` could match that of v1, inw hich case no import changes will be
necessary.

#### Migration Guide

A comprehensive guide for migrating cdk apps from v1 to v2 will be added to the aws-cdk documentation. A place for
future migration guides will be defined and a markdown document will be written detailing what steps users should take
when upgrading to cdk v2.

This guide will detail, for each supported programming language:

1. Ensuring the migrated application makes no use of `@deprecated` APIs
1. Ensuring the migrated application does not depend on a feature flag
   - For each feature flag, how to migrate to the `next` state
1. Replacing dependencies on `@aws-cdk` namespaced modules with `@aws-cdk/stdlin`
1. Upgrading version of `aws-cdk` and other toolchain packages to version `2.x`
1. Updating import statements (where needed) using the [provided tools](#import-rewriter)

## Release Cutover

After sufficient time releasing `next` with a prerelease identifier (`v2.0.0-dev.X`), it will be decided that `next` is
ready for General Availability. The lead up to releasing `2.0.0` is composed of the following high-level steps:

1. Publicly declare the beginning of a Developer Preview phase, and start releasing as `v2.0.0-preview`
   - This should include the publishing of a maintenance plan for v1
1. Dial down automated forward-porting of new v1 changes
   - Stop automatically pushing changes to the `next` branch, submit PRs instead
   - Encourage users to consider rebasing their PRs to `next` instead of `main`
1. Vet the new release with as much real-world usage as possible, gaining confidence the product is good
1. When ready, make `v2.0.0` Generally Available
   - Stop automatically forward-porting changes from v1 to `next`
   - Rename the `main` branch to `v1` (updating the base of all existing PRs)
   - Rename the `next` branch to `main` (updating the abse of all existing PRs)

## Additional Candidates for Inclusion:

The following are changes whose implementation's have been identified as requiring a breaking change. Inclusion in the
v2 release is up for debate. Arguments to include a specific feature should take into account any increase in cost to
the development team required to ship the release, and to users required to migrate their apps to the new version.
Though we want to keep both of these costs as low as possible, a breaking release is something that happens relatively
infrequently, so the opportunity should be taken to include features determined to have a high payoff to users.

In addition, since the v1 modules will continue to be supported for some time, and the `@aws-cdk/stdlib` package will be
made of up these modules, the inclusion of any of these candidate features would need to be implemented in a way that
didn't affect the v1 modules. How this would be done has not been determined, but may be affected by the nature of any
particular change.

### Recommended

The following are good candidates for inclusion in this major version release

#### [Easier Identification of Experimental Modules and APIs](https://github.com/aws/aws-cdk-rfcs/issues/116)

There have been long running discussions about separating experimental APIs into a separate module to make them a more
explicit "opt in" feature. Users would either have to install a different module (i.e. `@aws-cdk/stdlib-exerimental`) or
import from a different entrypoint (`import * as s3 from '@aws-cdk/stdlib/experimental`). Since this could be performed
at build time and be an optional setting thats turned on or off, it could be introduced in the 2.0 release without
affecting the v1 modules, this seems like an ideal time to implement. The technical details of how to achieve this are
yet to be determined.

#### [Public S3 Artifacts](https://github.com/aws/aws-cdk-rfcs/issues/39)

A significant downside of packaging all of the aws service construct libraries together is that the size of dependencies
shipped to the users in most cases will be increased significantly. Being able to remove assets, like custom resource
lambda code, that are currently bundled with the modules, could mitigate some of the impact on package size. This could
be accomplished by packaging said assets, uploading them to S3, and then creating publically accessible lambda function
layers referencing them across all AWS regions. Whether v2 of the cdk could accomplish this without impacting v1 has not
been determined.

#### [Rename ID Parameter](https://github.com/aws/aws-cdk/issues/3203)

`id` is a reserved keyword in python. Renaming this parameter in constructs prevents possible errors. This likely could
be implemented as a feature flag with the flag removed as part of the normal major version release process.

There are other parameter or API names that are known to produce degrated experience for developers in other languages,
including (possibly not limited to):

- `self`
- `Function`

### Not Recommended

The following require more research to be implemented without causing undue breakage.

#### [Unmangled L2 Logical IDs](https://github.com/aws/aws-cdk/issues/1687)

Changing logical ID generation in any capacity could cost users with existing CDK apps a lot of pain. To deploy their
stacks without breaking deployed resources, they may have to change IDs and/or certain property parameters passed to
resource constructor functions. Because of this, the change will not be included in the 2.0 release cycle. Future
investigation should work towards the potential to implement this behind a feature flag and, if possible, provide users
an automated way to make sure resources defined in existing stacks will not have their logical IDs changed causing them
to be torn down and replaced unexpectedly.

#### [Remove Custom Resource Implementation of Fargate Event Target](https://github.com/aws/aws-cdk/issues/3930)

Investigation should take place to discern if this could be changed without breaking the public API and/or existing
stack resources. If not, is creating a new construct and deprecating the old one at the top level a viable strategy for
constructs with planned breaking changes going forward? Is it appropriate to deprecate a portion of a construct
(constructor properties, etc) that would require resource replacement? Can we guide users through replacement of
constructs that are being deprecated to make sure they don't experience interruptions in service? Because of these
unknowns, it is unlikely that this will be included in the 2.0 release.

#### [Change Logical IDs to Avoid Potential Collisions](https://github.com/aws/aws-cdk/issues/6421)

Similar to aws/aws-cdk#1687, changing logical ID logic introduces a lot of problems for existing users. Whether
`LogicalIds 2.0` can be implemented behind a feature flag should be investigated to avoid breaking existing apps.

#### [AliasOptions and VersionOptions should not extend EventInvokeConfigOptions](https://github.com/aws/aws-cdk/issues/6966)

More information needed. @eladb

#### [Remove Support for Docker Assets with Parameters]()

More information needed. @eladb

# Drawbacks

The main drawback of this staged release strategy is the complexity we will incur within our build tooling to be more
version aware. Though doing things like selectively including or excluding deprecated APIs based on current version
allows us to phase the release of breaking changes without having to maintain a long lived branch for the upcoming
release, the potential for bugs in the functionality of these features could have downsides to users. If a deprecated
API is removed from a module when it shouldn't be, and that module is published, it will break user's applications.
Though this could of course be remedied in a patch release.

If a deprecated API isn't removed from a version that it was inteded to be, and users start relying on the presence of
that API, then by fixing the bug and removing the API in future versions we potentionally introduce breaking changes
that weren't intended by us or expected by the users.

Because of this reason, automated verification of our different builds and the presence/absence of APIs and feature
flags is, as always, of high importance.

The cost of migration for users varies depending on the state of the application being migrated. All users upgrading to
v2 will have to perform the following steps:

1. Update Dependencies - Changing from referencing the old `@aws-cdk/` packages to the new `@aws-cdk/stdlib` package in
   the corresponding target language's package manifest (package.json, .sln, pom.xml, setup.py).
1. Update Imports - Since the current module structure is being changed, import statements in user's code will need to
   change to accommodate the new structure. This will be automated wherever needed with the
   [import rewriter](#import-rewriter).

Users may have to make additional code changes when upgrading if they are relying on deprecated APIs or feature flags
that are being removed. This cost can be minimized through good documentation and information in the
[migration guide](#migration-guide).

# Rationale and Alternatives

## Rationale

The main motivation for moving forward with a 2.0 release now is the desire to start moving towards the single module
structure. The current multi module structure is known to cause a lot of confusion for users. For more details on why
aws-cdk is moving to a single package, see the [MonoCDK RFC](https://github.com/aws/aws-cdk-rfcs/issues/6).

This belief that releasing a single package will make user's lives easier is countered by a strong desire to limit the
exposure of users to breaking changes. Though the aws-cdk is relatively young, one of the core tenants of the project is
stability. Major version upgrades are an important part of building and maintaining libraries. However, limiting the
cost of breaking changes included in major releases is important. It isn't in the interest of the project to drop a new
major version, immediately stop supporting the previous version, and leave the onus on the user to "catch up".

Therefore, a major part of the motivation to perform this work is to establish a framework for releasing new major
versions of the cdk in a controlled and standardized way. Establishing standards and tools to automatically handle
deprecations, feature flag resets, and pre-release versioning will allow the core team and contributors to leverage
these to better control breakage. The path to introduce a breaking change is then a lot more clear.

First we ask, "can this be implemented behind a feature flag"? If so, that's usually the answer. Build tooling tells us
when feature flags can be removed and warns users when it has happened. Migration path to new behavior has to be
considered and should be documented clearly at the time the flag is created. This goes in the migration guide of the
next major version.

If it can't be implemented behind a feature flag, we ask "can a new code path be defined and the old one deprecated?".
Once again, migration path is considered and documented and it goes into the next major version migration guide.

If the migration path is too painful in either situation, can it be reduced somehow? Can it be automated? etc...

The desire to move forward with the change in packaging strategy has brought the need for these tools and procedures to
the forefront.

## Alternatives

The most notable alternative to releasing a new major version, is basically to not. This could be done a couple of ways.

The first is not moving forward with the packaging change at all. For the argument against that, see the
[MonoCDK RFC](https://github.com/aws/aws-cdk-rfcs/issues/6).

The second is to simply release the new module, `@aws-cdk/stdlib` locked to the same `1.x.x` version that the other
modules are currently locked to. In fact, that is the first stage of the release process, its just under the name
`monocdk-experiment`. This was a low cost way for the dev team, contributors, and users to experiment with the new
structure before investing too much towards it.

Regardless, the point of using this change to push towards a 2.0 release, is that the single package structure is "the
new cdk". Meaning, the long term plan is to only release the `@aws-cdk/stdlib` package and no longer publish the other
`@aws-cdk/` namespaced ones. The [MonoCDK RFC](https://github.com/aws/aws-cdk-rfcs/issues/6) has more info on the
problems currently experienced by users caused by the current packaging strategy and these problems will always exist
unless we stop supporting the `@aws-cdk/` packages.

Since we want to eventually supplant the current module structure with the new one, semver says we have to do it with
the release of a major version.

# Adoption Strategy

All users will perform the following to adopt cdk v2

1. Update Dependencies - Changing from referencing the old `@aws-cdk/` packages to the new `@aws-cdk/stdlib` package in
   the corresponding target language's package manifest (package.json, .sln, pom.xml, setup.py).
1. Update Imports - Since the current module structure is being changed, import statements in user's code will need to
   change to accommodate the change. This will be automated with the [import rewriter](#import-rewriter).

Users may have to make additional code changes when upgrading if they are relying on deprecated APIs or feature flags
that are being removed. A [migration guide](#migration-guide) will be written with details about each individual feature
flag and deprecated API that users may need to handle differently when upgrading.

# Unresolved questions

The bulk of unresolved questions are listed in the [detailed design](#detailed-design) section. To recap:

1. What additional features beyond adding the necessary tooling for releasing a major version going forward, should be
   included if any?
1. What will be the maintenance plan for v1 once v2 is generally available?

# Future Possibilities

As our first major version post 1.0, this sets the tone for others going forward. The 2.0 release is looking to be
relatively painless for users to adopt. The only code change required, if any at all, should be completely automated.
The challenge for the future is to maintain that experience whenever possible, and wherever it isn't, give users plenty
of time and warning to change their code and provide details about a reasonable path to do so without interruptions to
their existing cloud resources.
